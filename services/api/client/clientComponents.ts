/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useClientContext, ClientContext } from "./clientContext";
import type * as Fetcher from "./clientFetcher";
import { clientFetch } from "./clientFetcher";
import type * as Schemas from "./clientSchemas";

export type ChainControllerFindAllQueryParams = {
  name?: string;
  offset?: number;
  limit?: number;
};

export type ChainControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ChainControllerFindAllResponse = {
  total: number;
  limit: number;
  offset: number;
  count: number;
  results: Schemas.ChainDto[];
};

export type ChainControllerFindAllVariables = {
  queryParams?: ChainControllerFindAllQueryParams;
} & ClientContext["fetcherOptions"];

export const fetchChainControllerFindAll = (
  variables: ChainControllerFindAllVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    ChainControllerFindAllResponse,
    ChainControllerFindAllError,
    undefined,
    {},
    ChainControllerFindAllQueryParams,
    {}
  >({ url: "/api/v1/chain", method: "get", ...variables, signal });

export const useChainControllerFindAll = <
  TData = ChainControllerFindAllResponse
>(
  variables: ChainControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ChainControllerFindAllResponse,
      ChainControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    ChainControllerFindAllResponse,
    ChainControllerFindAllError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/chain",
      operationId: "chainControllerFindAll",
      variables,
    }),
    ({ signal }) =>
      fetchChainControllerFindAll({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type ChainControllerFindOnePathParams = {
  id: string;
};

export type ChainControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ChainControllerFindOneVariables = {
  pathParams: ChainControllerFindOnePathParams;
} & ClientContext["fetcherOptions"];

export const fetchChainControllerFindOne = (
  variables: ChainControllerFindOneVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.ChainDto,
    ChainControllerFindOneError,
    undefined,
    {},
    {},
    ChainControllerFindOnePathParams
  >({ url: "/api/v1/chain/{id}", method: "get", ...variables, signal });

export const useChainControllerFindOne = <TData = Schemas.ChainDto>(
  variables: ChainControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ChainDto,
      ChainControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.ChainDto,
    ChainControllerFindOneError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/chain/{id}",
      operationId: "chainControllerFindOne",
      variables,
    }),
    ({ signal }) =>
      fetchChainControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UserControllerRegisterError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerRegisterVariables = {
  body: Schemas.RegisterUserDto;
} & ClientContext["fetcherOptions"];

export const fetchUserControllerRegister = (
  variables: UserControllerRegisterVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.UserDto,
    UserControllerRegisterError,
    Schemas.RegisterUserDto,
    {},
    {},
    {}
  >({ url: "/api/v1/user/register", method: "post", ...variables, signal });

export const useUserControllerRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserDto,
      UserControllerRegisterError,
      UserControllerRegisterVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useClientContext();
  return reactQuery.useMutation<
    Schemas.UserDto,
    UserControllerRegisterError,
    UserControllerRegisterVariables
  >(
    (variables: UserControllerRegisterVariables) =>
      fetchUserControllerRegister({ ...fetcherOptions, ...variables }),
    options
  );
};

export type UserControllerAuthenticateError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerAuthenticateVariables = {
  body: Schemas.UserLoginDto;
} & ClientContext["fetcherOptions"];

export const fetchUserControllerAuthenticate = (
  variables: UserControllerAuthenticateVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.UserDto,
    UserControllerAuthenticateError,
    Schemas.UserLoginDto,
    {},
    {},
    {}
  >({ url: "/api/v1/user/auth", method: "post", ...variables, signal });

export const useUserControllerAuthenticate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserDto,
      UserControllerAuthenticateError,
      UserControllerAuthenticateVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useClientContext();
  return reactQuery.useMutation<
    Schemas.UserDto,
    UserControllerAuthenticateError,
    UserControllerAuthenticateVariables
  >(
    (variables: UserControllerAuthenticateVariables) =>
      fetchUserControllerAuthenticate({ ...fetcherOptions, ...variables }),
    options
  );
};

export type NftControllerFindAllQueryParams = {
  account_id: string;
  name?: string;
  nft_type_id?: string;
  campaign_id?: string;
  offset?: number;
  limit?: number;
};

export type NftControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerFindAllResponse = {
  total: number;
  limit: number;
  offset: number;
  count: number;
  results: Schemas.UserNftDto[];
};

export type NftControllerFindAllVariables = {
  queryParams: NftControllerFindAllQueryParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerFindAll = (
  variables: NftControllerFindAllVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    NftControllerFindAllResponse,
    NftControllerFindAllError,
    undefined,
    {},
    NftControllerFindAllQueryParams,
    {}
  >({ url: "/api/v1/nft", method: "get", ...variables, signal });

export const useNftControllerFindAll = <TData = NftControllerFindAllResponse>(
  variables: NftControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      NftControllerFindAllResponse,
      NftControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    NftControllerFindAllResponse,
    NftControllerFindAllError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/nft",
      operationId: "nftControllerFindAll",
      variables,
    }),
    ({ signal }) =>
      fetchNftControllerFindAll({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type NftControllerFindOnePathParams = {
  nftId: string;
  accountId: string;
};

export type NftControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerFindOneVariables = {
  pathParams: NftControllerFindOnePathParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerFindOne = (
  variables: NftControllerFindOneVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.UserNftDto,
    NftControllerFindOneError,
    undefined,
    {},
    {},
    NftControllerFindOnePathParams
  >({
    url: "/api/v1/nft/user/{nftId}/{accountId}",
    method: "get",
    ...variables,
    signal,
  });

export const useNftControllerFindOne = <TData = Schemas.UserNftDto>(
  variables: NftControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserNftDto,
      NftControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.UserNftDto,
    NftControllerFindOneError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/nft/user/{nft_id}/{account_id}",
      operationId: "nftControllerFindOne",
      variables,
    }),
    ({ signal }) =>
      fetchNftControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type NftControllerFindOneNftPathParams = {
  nftId: string;
};

export type NftControllerFindOneNftError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerFindOneNftVariables = {
  pathParams: NftControllerFindOneNftPathParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerFindOneNft = (
  variables: NftControllerFindOneNftVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.NftDto,
    NftControllerFindOneNftError,
    undefined,
    {},
    {},
    NftControllerFindOneNftPathParams
  >({ url: "/api/v1/nft/{nftId}", method: "get", ...variables, signal });

export const useNftControllerFindOneNft = <TData = Schemas.NftDto>(
  variables: NftControllerFindOneNftVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.NftDto,
      NftControllerFindOneNftError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.NftDto,
    NftControllerFindOneNftError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/nft/{nft_id}",
      operationId: "nftControllerFindOneNft",
      variables,
    }),
    ({ signal }) =>
      fetchNftControllerFindOneNft({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type NftControllerDropNftPathParams = {
  nftId: string;
  accountId: string;
};

export type NftControllerDropNftError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerDropNftVariables = {
  pathParams: NftControllerDropNftPathParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerDropNft = (
  variables: NftControllerDropNftVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.UserNftDto,
    NftControllerDropNftError,
    undefined,
    {},
    {},
    NftControllerDropNftPathParams
  >({
    url: "/api/v1/nft/drop/{nftId}/{accountId}",
    method: "post",
    ...variables,
    signal,
  });

export const useNftControllerDropNft = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserNftDto,
      NftControllerDropNftError,
      NftControllerDropNftVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useClientContext();
  return reactQuery.useMutation<
    Schemas.UserNftDto,
    NftControllerDropNftError,
    NftControllerDropNftVariables
  >(
    (variables: NftControllerDropNftVariables) =>
      fetchNftControllerDropNft({ ...fetcherOptions, ...variables }),
    options
  );
};

export type NftControllerPreviewOrderPathParams = {
  nftId: string;
};

export type NftControllerPreviewOrderError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerPreviewOrderVariables = {
  pathParams: NftControllerPreviewOrderPathParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerPreviewOrder = (
  variables: NftControllerPreviewOrderVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.NftCostDto,
    NftControllerPreviewOrderError,
    undefined,
    {},
    {},
    NftControllerPreviewOrderPathParams
  >({
    url: "/api/v1/nft/calculate-order-price/{nftId}",
    method: "get",
    ...variables,
    signal,
  });

export const useNftControllerPreviewOrder = <TData = Schemas.NftCostDto>(
  variables: NftControllerPreviewOrderVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.NftCostDto,
      NftControllerPreviewOrderError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.NftCostDto,
    NftControllerPreviewOrderError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/nft/calculate-order-price/{nft_id}",
      operationId: "nftControllerPreviewOrder",
      variables,
    }),
    ({ signal }) =>
      fetchNftControllerPreviewOrder(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type NftControllerCreatePaymentError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerCreatePaymentVariables = {
  body: Schemas.NftOrderRequestDto;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerCreatePayment = (
  variables: NftControllerCreatePaymentVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.NftOrderRequestDto,
    NftControllerCreatePaymentError,
    Schemas.NftOrderRequestDto,
    {},
    {},
    {}
  >({ url: "/api/v1/nft/create-order", method: "post", ...variables, signal });

export const useNftControllerCreatePayment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.NftOrderRequestDto,
      NftControllerCreatePaymentError,
      NftControllerCreatePaymentVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useClientContext();
  return reactQuery.useMutation<
    Schemas.NftOrderRequestDto,
    NftControllerCreatePaymentError,
    NftControllerCreatePaymentVariables
  >(
    (variables: NftControllerCreatePaymentVariables) =>
      fetchNftControllerCreatePayment({ ...fetcherOptions, ...variables }),
    options
  );
};

export type NftControllerGetNftMediaPathParams = {
  tokenId: string;
};

export type NftControllerGetNftMediaError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerGetNftMediaVariables = {
  pathParams: NftControllerGetNftMediaPathParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerGetNftMedia = (
  variables: NftControllerGetNftMediaVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.StreamableFile,
    NftControllerGetNftMediaError,
    undefined,
    {},
    {},
    NftControllerGetNftMediaPathParams
  >({
    url: "/api/v1/nft/{tokenId}/media",
    method: "get",
    ...variables,
    signal,
  });

export const useNftControllerGetNftMedia = <TData = Schemas.StreamableFile>(
  variables: NftControllerGetNftMediaVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.StreamableFile,
      NftControllerGetNftMediaError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.StreamableFile,
    NftControllerGetNftMediaError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/nft/{tokenId}/media",
      operationId: "nftControllerGetNftMedia",
      variables,
    }),
    ({ signal }) =>
      fetchNftControllerGetNftMedia(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type CampaignUserControllerFindOnePathParams = {
  campaignId: string;
};

export type CampaignUserControllerFindOneError =
  Fetcher.ErrorWrapper<undefined>;

export type CampaignUserControllerFindOneVariables = {
  pathParams: CampaignUserControllerFindOnePathParams;
} & ClientContext["fetcherOptions"];

export const fetchCampaignUserControllerFindOne = (
  variables: CampaignUserControllerFindOneVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.CampaignDto,
    CampaignUserControllerFindOneError,
    undefined,
    {},
    {},
    CampaignUserControllerFindOnePathParams
  >({
    url: "/api/v1/campaign-user/{campaignId}",
    method: "get",
    ...variables,
    signal,
  });

export const useCampaignUserControllerFindOne = <TData = Schemas.CampaignDto>(
  variables: CampaignUserControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CampaignDto,
      CampaignUserControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.CampaignDto,
    CampaignUserControllerFindOneError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/campaign-user/{campaign_id}",
      operationId: "campaignUserControllerFindOne",
      variables,
    }),
    ({ signal }) =>
      fetchCampaignUserControllerFindOne(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type CampaignUserControllerFindAllQueryParams = {
  account_id: string;
  offset?: number;
  limit?: number;
};

export type CampaignUserControllerFindAllError =
  Fetcher.ErrorWrapper<undefined>;

export type CampaignUserControllerFindAllResponse = {
  total: number;
  limit: number;
  offset: number;
  count: number;
  results: Schemas.CampaignDto[];
};

export type CampaignUserControllerFindAllVariables = {
  queryParams: CampaignUserControllerFindAllQueryParams;
} & ClientContext["fetcherOptions"];

export const fetchCampaignUserControllerFindAll = (
  variables: CampaignUserControllerFindAllVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    CampaignUserControllerFindAllResponse,
    CampaignUserControllerFindAllError,
    undefined,
    {},
    CampaignUserControllerFindAllQueryParams,
    {}
  >({ url: "/api/v1/campaign-user", method: "get", ...variables, signal });

export const useCampaignUserControllerFindAll = <
  TData = CampaignUserControllerFindAllResponse
>(
  variables: CampaignUserControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      CampaignUserControllerFindAllResponse,
      CampaignUserControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    CampaignUserControllerFindAllResponse,
    CampaignUserControllerFindAllError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/campaign-user",
      operationId: "campaignUserControllerFindAll",
      variables,
    }),
    ({ signal }) =>
      fetchCampaignUserControllerFindAll(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type CampaignUserControllerGetNftMediaPathParams = {
  fileId: string;
};

export type CampaignUserControllerGetNftMediaError =
  Fetcher.ErrorWrapper<undefined>;

export type CampaignUserControllerGetNftMediaVariables = {
  pathParams: CampaignUserControllerGetNftMediaPathParams;
} & ClientContext["fetcherOptions"];

export const fetchCampaignUserControllerGetNftMedia = (
  variables: CampaignUserControllerGetNftMediaVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.StreamableFile,
    CampaignUserControllerGetNftMediaError,
    undefined,
    {},
    {},
    CampaignUserControllerGetNftMediaPathParams
  >({
    url: "/api/v1/campaign-user/{fileId}/media",
    method: "get",
    ...variables,
    signal,
  });

export const useCampaignUserControllerGetNftMedia = <
  TData = Schemas.StreamableFile
>(
  variables: CampaignUserControllerGetNftMediaVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.StreamableFile,
      CampaignUserControllerGetNftMediaError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.StreamableFile,
    CampaignUserControllerGetNftMediaError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/campaign-user/{file_id}/media",
      operationId: "campaignUserControllerGetNftMedia",
      variables,
    }),
    ({ signal }) =>
      fetchCampaignUserControllerGetNftMedia(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type StripeControllerGetProductPathParams = {
  id: string;
};

export type StripeControllerGetProductError = Fetcher.ErrorWrapper<undefined>;

export type StripeControllerGetProductVariables = {
  pathParams: StripeControllerGetProductPathParams;
} & ClientContext["fetcherOptions"];

export const fetchStripeControllerGetProduct = (
  variables: StripeControllerGetProductVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.ProductDto,
    StripeControllerGetProductError,
    undefined,
    {},
    {},
    StripeControllerGetProductPathParams
  >({
    url: "/api/v1/stripe/products/{id}",
    method: "get",
    ...variables,
    signal,
  });

export const useStripeControllerGetProduct = <TData = Schemas.ProductDto>(
  variables: StripeControllerGetProductVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ProductDto,
      StripeControllerGetProductError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.ProductDto,
    StripeControllerGetProductError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/stripe/products/{id}",
      operationId: "stripeControllerGetProduct",
      variables,
    }),
    ({ signal }) =>
      fetchStripeControllerGetProduct(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type StripeControllerGetProductsError = Fetcher.ErrorWrapper<undefined>;

export type StripeControllerGetProductsResponse = {
  total: number;
  limit: number;
  offset: number;
  count: number;
  results: Schemas.ProductDto[];
};

export type StripeControllerGetProductsVariables =
  ClientContext["fetcherOptions"];

export const fetchStripeControllerGetProducts = (
  variables: StripeControllerGetProductsVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    StripeControllerGetProductsResponse,
    StripeControllerGetProductsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/stripe/products", method: "get", ...variables, signal });

export const useStripeControllerGetProducts = <
  TData = StripeControllerGetProductsResponse
>(
  variables: StripeControllerGetProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      StripeControllerGetProductsResponse,
      StripeControllerGetProductsError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    StripeControllerGetProductsResponse,
    StripeControllerGetProductsError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/stripe/products",
      operationId: "stripeControllerGetProducts",
      variables,
    }),
    ({ signal }) =>
      fetchStripeControllerGetProducts(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type StripeControllerChargeCapturedError =
  Fetcher.ErrorWrapper<undefined>;

export type StripeControllerChargeCapturedVariables =
  ClientContext["fetcherOptions"];

export const fetchStripeControllerChargeCaptured = (
  variables: StripeControllerChargeCapturedVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    undefined,
    StripeControllerChargeCapturedError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/v1/stripe/webhook", method: "post", ...variables, signal });

export const useStripeControllerChargeCaptured = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      StripeControllerChargeCapturedError,
      StripeControllerChargeCapturedVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useClientContext();
  return reactQuery.useMutation<
    undefined,
    StripeControllerChargeCapturedError,
    StripeControllerChargeCapturedVariables
  >(
    (variables: StripeControllerChargeCapturedVariables) =>
      fetchStripeControllerChargeCaptured({ ...fetcherOptions, ...variables }),
    options
  );
};

export type QueryOperation =
  | {
      path: "/api/v1/chain";
      operationId: "chainControllerFindAll";
      variables: ChainControllerFindAllVariables;
    }
  | {
      path: "/api/v1/chain/{id}";
      operationId: "chainControllerFindOne";
      variables: ChainControllerFindOneVariables;
    }
  | {
      path: "/api/v1/nft";
      operationId: "nftControllerFindAll";
      variables: NftControllerFindAllVariables;
    }
  | {
      path: "/api/v1/nft/user/{nft_id}/{account_id}";
      operationId: "nftControllerFindOne";
      variables: NftControllerFindOneVariables;
    }
  | {
      path: "/api/v1/nft/{nft_id}";
      operationId: "nftControllerFindOneNft";
      variables: NftControllerFindOneNftVariables;
    }
  | {
      path: "/api/v1/nft/calculate-order-price/{nft_id}";
      operationId: "nftControllerPreviewOrder";
      variables: NftControllerPreviewOrderVariables;
    }
  | {
      path: "/api/v1/nft/{tokenId}/media";
      operationId: "nftControllerGetNftMedia";
      variables: NftControllerGetNftMediaVariables;
    }
  | {
      path: "/api/v1/campaign-user/{campaign_id}";
      operationId: "campaignUserControllerFindOne";
      variables: CampaignUserControllerFindOneVariables;
    }
  | {
      path: "/api/v1/campaign-user";
      operationId: "campaignUserControllerFindAll";
      variables: CampaignUserControllerFindAllVariables;
    }
  | {
      path: "/api/v1/campaign-user/{file_id}/media";
      operationId: "campaignUserControllerGetNftMedia";
      variables: CampaignUserControllerGetNftMediaVariables;
    }
  | {
      path: "/api/v1/stripe/products/{id}";
      operationId: "stripeControllerGetProduct";
      variables: StripeControllerGetProductVariables;
    }
  | {
      path: "/api/v1/stripe/products";
      operationId: "stripeControllerGetProducts";
      variables: StripeControllerGetProductsVariables;
    };
