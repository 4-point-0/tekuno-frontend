/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useClientContext, ClientContext } from "./clientContext";
import type * as Fetcher from "./clientFetcher";
import { clientFetch } from "./clientFetcher";
import type * as Schemas from "./clientSchemas";

export type ChainControllerFindAllQueryParams = {
  name?: string;
  offset?: number;
  limit?: number;
};

export type ChainControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type ChainControllerFindAllResponse = {
  total: number;
  limit: number;
  offset: number;
  count: number;
  results: Schemas.ChainDto[];
};

export type ChainControllerFindAllVariables = {
  queryParams?: ChainControllerFindAllQueryParams;
} & ClientContext["fetcherOptions"];

export const fetchChainControllerFindAll = (
  variables: ChainControllerFindAllVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    ChainControllerFindAllResponse,
    ChainControllerFindAllError,
    undefined,
    {},
    ChainControllerFindAllQueryParams,
    {}
  >({ url: "/api/v1/chain", method: "get", ...variables, signal });

export const useChainControllerFindAll = <
  TData = ChainControllerFindAllResponse
>(
  variables: ChainControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ChainControllerFindAllResponse,
      ChainControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    ChainControllerFindAllResponse,
    ChainControllerFindAllError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/chain",
      operationId: "chainControllerFindAll",
      variables,
    }),
    ({ signal }) =>
      fetchChainControllerFindAll({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type ChainControllerFindOnePathParams = {
  id: string;
};

export type ChainControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type ChainControllerFindOneVariables = {
  pathParams: ChainControllerFindOnePathParams;
} & ClientContext["fetcherOptions"];

export const fetchChainControllerFindOne = (
  variables: ChainControllerFindOneVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.ChainDto,
    ChainControllerFindOneError,
    undefined,
    {},
    {},
    ChainControllerFindOnePathParams
  >({ url: "/api/v1/chain/{id}", method: "get", ...variables, signal });

export const useChainControllerFindOne = <TData = Schemas.ChainDto>(
  variables: ChainControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ChainDto,
      ChainControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.ChainDto,
    ChainControllerFindOneError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/chain/{id}",
      operationId: "chainControllerFindOne",
      variables,
    }),
    ({ signal }) =>
      fetchChainControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UserControllerRegisterError = Fetcher.ErrorWrapper<undefined>;

export type UserControllerRegisterVariables = {
  body: Schemas.RegisterUserDto;
} & ClientContext["fetcherOptions"];

export const fetchUserControllerRegister = (
  variables: UserControllerRegisterVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.UserDto,
    UserControllerRegisterError,
    Schemas.RegisterUserDto,
    {},
    {},
    {}
  >({ url: "/api/v1/user/register", method: "post", ...variables, signal });

export const useUserControllerRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserDto,
      UserControllerRegisterError,
      UserControllerRegisterVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useClientContext();
  return reactQuery.useMutation<
    Schemas.UserDto,
    UserControllerRegisterError,
    UserControllerRegisterVariables
  >(
    (variables: UserControllerRegisterVariables) =>
      fetchUserControllerRegister({ ...fetcherOptions, ...variables }),
    options
  );
};

export type NftControllerFindAllQueryParams = {
  account_id: string;
  name?: string;
  nft_type_id?: string;
  campaign_id?: string;
  offset?: number;
  limit?: number;
};

export type NftControllerFindAllError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerFindAllResponse = {
  total: number;
  limit: number;
  offset: number;
  count: number;
  results: Schemas.UserNftDto[];
};

export type NftControllerFindAllVariables = {
  queryParams: NftControllerFindAllQueryParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerFindAll = (
  variables: NftControllerFindAllVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    NftControllerFindAllResponse,
    NftControllerFindAllError,
    undefined,
    {},
    NftControllerFindAllQueryParams,
    {}
  >({ url: "/api/v1/nft", method: "get", ...variables, signal });

export const useNftControllerFindAll = <TData = NftControllerFindAllResponse>(
  variables: NftControllerFindAllVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      NftControllerFindAllResponse,
      NftControllerFindAllError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    NftControllerFindAllResponse,
    NftControllerFindAllError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/nft",
      operationId: "nftControllerFindAll",
      variables,
    }),
    ({ signal }) =>
      fetchNftControllerFindAll({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type NftControllerFindOnePathParams = {
  nftId: string;
  accountId: string;
};

export type NftControllerFindOneError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerFindOneVariables = {
  pathParams: NftControllerFindOnePathParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerFindOne = (
  variables: NftControllerFindOneVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.UserNftDto,
    NftControllerFindOneError,
    undefined,
    {},
    {},
    NftControllerFindOnePathParams
  >({
    url: "/api/v1/nft/{nftId}/{accountId}",
    method: "get",
    ...variables,
    signal,
  });

export const useNftControllerFindOne = <TData = Schemas.UserNftDto>(
  variables: NftControllerFindOneVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.UserNftDto,
      NftControllerFindOneError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.UserNftDto,
    NftControllerFindOneError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/nft/{nft_id}/{account_id}",
      operationId: "nftControllerFindOne",
      variables,
    }),
    ({ signal }) =>
      fetchNftControllerFindOne({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type NftControllerDropNftPathParams = {
  nftId: string;
  accountId: string;
};

export type NftControllerDropNftError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerDropNftVariables = {
  pathParams: NftControllerDropNftPathParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerDropNft = (
  variables: NftControllerDropNftVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.UserNftDto,
    NftControllerDropNftError,
    undefined,
    {},
    {},
    NftControllerDropNftPathParams
  >({
    url: "/api/v1/nft/drop/{nftId}/{accountId}",
    method: "post",
    ...variables,
    signal,
  });

export const useNftControllerDropNft = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserNftDto,
      NftControllerDropNftError,
      NftControllerDropNftVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useClientContext();
  return reactQuery.useMutation<
    Schemas.UserNftDto,
    NftControllerDropNftError,
    NftControllerDropNftVariables
  >(
    (variables: NftControllerDropNftVariables) =>
      fetchNftControllerDropNft({ ...fetcherOptions, ...variables }),
    options
  );
};

export type NftControllerGetNftMediaPathParams = {
  tokenId: string;
};

export type NftControllerGetNftMediaError = Fetcher.ErrorWrapper<undefined>;

export type NftControllerGetNftMediaVariables = {
  pathParams: NftControllerGetNftMediaPathParams;
} & ClientContext["fetcherOptions"];

export const fetchNftControllerGetNftMedia = (
  variables: NftControllerGetNftMediaVariables,
  signal?: AbortSignal
) =>
  clientFetch<
    Schemas.StreamableFile,
    NftControllerGetNftMediaError,
    undefined,
    {},
    {},
    NftControllerGetNftMediaPathParams
  >({
    url: "/api/v1/nft/{tokenId}/media",
    method: "get",
    ...variables,
    signal,
  });

export const useNftControllerGetNftMedia = <TData = Schemas.StreamableFile>(
  variables: NftControllerGetNftMediaVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.StreamableFile,
      NftControllerGetNftMediaError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useClientContext(options);
  return reactQuery.useQuery<
    Schemas.StreamableFile,
    NftControllerGetNftMediaError,
    TData
  >(
    queryKeyFn({
      path: "/api/v1/nft/{tokenId}/media",
      operationId: "nftControllerGetNftMedia",
      variables,
    }),
    ({ signal }) =>
      fetchNftControllerGetNftMedia(
        { ...fetcherOptions, ...variables },
        signal
      ),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type QueryOperation =
  | {
      path: "/api/v1/chain";
      operationId: "chainControllerFindAll";
      variables: ChainControllerFindAllVariables;
    }
  | {
      path: "/api/v1/chain/{id}";
      operationId: "chainControllerFindOne";
      variables: ChainControllerFindOneVariables;
    }
  | {
      path: "/api/v1/nft";
      operationId: "nftControllerFindAll";
      variables: NftControllerFindAllVariables;
    }
  | {
      path: "/api/v1/nft/{nft_id}/{account_id}";
      operationId: "nftControllerFindOne";
      variables: NftControllerFindOneVariables;
    }
  | {
      path: "/api/v1/nft/{tokenId}/media";
      operationId: "nftControllerGetNftMedia";
      variables: NftControllerGetNftMediaVariables;
    };
